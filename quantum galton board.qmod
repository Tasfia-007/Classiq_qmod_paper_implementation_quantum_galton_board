struct CustomBias {
  addCustomBias: bool;
  bias_angle: real;
}

qfunc CSWAP(ctrl: qbit, a: qbit, b: qbit) {
  control (ctrl) {
    SWAP(a, b);
  }
}

qfunc apply_peg_interaction(
  control_qubit: qbit,
  left_channel: qbit,
  peg: qbit,
  right_channel: qbit
) {
  CSWAP(control_qubit, left_channel, peg);
  CX(peg, control_qubit);
  CSWAP(control_qubit, peg, right_channel);
}

qfunc process_layer_with_reset(
  layer: int,
  n_layers: int,
  control_qubit: qbit,
  bin_qubits: qbit[],
  ancilla_qubits: qbit[],
  bias: CustomBias
) {
  // Apply reset
  RESET(control_qubit);

  // Apply custom bias
  if (bias.addCustomBias == True) {
    RX(bias.bias_angle, control_qubit);
  }
  else {
    H(control_qubit);
  }
  
  repeat (i: layer + 1) {
    apply_peg_interaction(
      control_qubit,
      bin_qubits[i],
      ancilla_qubits[(n_layers - layer - 1) + i],
      bin_qubits[i + 1]
    );
    
    if (i < layer) {
      CX(bin_qubits[i + 1], control_qubit);
    }
  }
}

qfunc process_layer_without_reset(
  layer: int,
  n_layers: int,
  control_qubit: qbit,
  bin_qubits: qbit[],
  ancilla_qubits: qbit[],
  bias: CustomBias
) {
  // Apply custom bias
  if (bias.addCustomBias == True) {
    RX(bias.bias_angle, control_qubit);
  }
  else {
    H(control_qubit);
  }
  
  repeat (i: layer + 1) {
    apply_peg_interaction(
      control_qubit,
      bin_qubits[i],
      ancilla_qubits[(n_layers - layer - 1) + i],
      bin_qubits[i + 1]
    );
    
    if (i < layer) {
      CX(bin_qubits[i + 1], control_qubit);
    }
  }
}

qfunc quantum_galton_board(
  n_layers: int,
  control_qubit: qbit,
  bin_qubits: qbit[],
  ancilla_qubits: qbit[],
  classical: bool,
  bias: CustomBias
) {
  // Initialize the ball at the top (center position)
  X(bin_qubits[0]);
  
  repeat (layer: n_layers) {
    if(classical == True) {
      process_layer_with_reset(layer, n_layers, control_qubit, bin_qubits, ancilla_qubits, bias);
    }
    else {
      process_layer_without_reset(layer, n_layers, control_qubit, bin_qubits, ancilla_qubits, bias);
    }
  }
}

// For n layer Galton quantum_galton_board there will be
// n + 1 bin qubits and n anciliary qubits

qfunc main(output bins: qbit[5]) {
  control_qubit: qbit;
  ancilla_qubits: qbit[4]; 
  
  allocate(1, control_qubit);
  allocate(4, ancilla_qubits);
  allocate(5, bins);
  
  // bins is already our output array with n+1 = 5 qubits
  quantum_galton_board(4, control_qubit, bins, ancilla_qubits, True, CustomBias{ addCustomBias = False, bias_angle = (pi / 3)});
}